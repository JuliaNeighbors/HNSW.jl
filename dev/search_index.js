var documenterSearchIndex = {"docs":
[{"location":"api/#HNSW-API","page":"API","title":"HNSW API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = HNSW","category":"page"},{"location":"api/","page":"API","title":"API","text":"HierarchicalNSW(data)\nHierarchicalNSW(type::Type)\nadd_to_graph!\nset_ef!\nadd!\nknn_search","category":"page"},{"location":"api/#HNSW.HierarchicalNSW-Tuple{Any}","page":"API","title":"HNSW.HierarchicalNSW","text":"HierarchicalNSW(data;\n    metric=Euclidean(),\n    M=10,\n    M0=2M,\n    m_L=1 / log(M),\n    efConstruction=100,\n    ef=10,\n    max_elements=length(data)\n\nCreate HNSW structures based on data.\n\ndata: This is an AbstractVector of the data points to be used.\nmetric: The metric to use for distance calculation. Any metric defined in Distances.jl should work as well as any type for which evaluate(::CustomMetric, x,y) is implemented.\nM: The maximum number of links per node on a level >1. Note that value highly influences recall depending on data.\nM0: The maximum number of links on the bottom layer (=1). Defaults to M0 = 2M.\nefConstruction: Maximum length of dynamic link lists during index creation. Low values may reduce recall but large values increase runtime of index creation.\nef: Maximum length of dynamic link lists during search. May be changed afterwards using set_ef!(hnsw, value)\nm_L: Prefactor for random level generation.\nmax_elements: May be set to a larger value in case one wants to add elements to the structure after initial creation.\n\nNote: the data object will be used as a primary storage of the the vectors. Don't change it outside HNSW after initialization.\n\nSample:\n\nusing HNSW\n\ndim = 10\nnum_elements = 10000\ndata = [rand(dim) for i=1:num_elements]\n\n#Intialize HNSW struct\nhnsw = HierarchicalNSW(data; efConstruction=100, M=16, ef=50)\n\n#Add all data points into the graph\n#Optionally pass a subset of the indices in data to partially construct the graph\nadd_to_graph!(hnsw)\n\n\n\n\n\n","category":"method"},{"location":"api/#HNSW.HierarchicalNSW-Tuple{Type}","page":"API","title":"HNSW.HierarchicalNSW","text":"HierarchicalNSW(vector_type::Type;\n    metric=Euclidean(),\n    M=10, #5 to 48\n    M0=2M,\n    m_L=1 / log(M),\n    efConstruction=100,\n    ef=10,\n    max_elements=100000\n)\n\nThis case constructs an empty HNSW graph based on the vector_type. Any data should be added with add! method.\n\nExample:\n\ndim = 5\nnum_elements = 100\ndata = [rand(Float32, dim) for n ∈ 1:num_elements]\n\nhnsw = HierarchicalNSW(eltype(data))\n\n# Now add new data\nHNSW.add!(hnsw, data)\n\n\n\n\n\n","category":"method"},{"location":"api/#HNSW.add_to_graph!","page":"API","title":"HNSW.add_to_graph!","text":"add_to_graph!(notify_func, hnsw, indices, multithreading=false)\n\nAdd i ∈ indices referring to data[i] into the graph.\n\nnotify_func(i) provides an interface for a progress notification by current index.\n\nIndices already added previously will be ignored.\n\n\n\n\n\nadd_to_graph!(hnsw, indices)\n\nshort form of add_to_graph!(notify_func, hnsw, indices)\n\n\n\n\n\n","category":"function"},{"location":"api/#HNSW.add!","page":"API","title":"HNSW.add!","text":"add!(hnsw, newdata)\n\nAdd new data to the graph.\n\n\n\n\n\n","category":"function"},{"location":"others/#All-internal-functions","page":"All functions","title":"All internal functions","text":"","category":"section"},{"location":"others/","page":"All functions","title":"All functions","text":"Modules = [HNSW]","category":"page"},{"location":"others/#HNSW.HierarchicalNSW","page":"All functions","title":"HNSW.HierarchicalNSW","text":"HierarchicalNSW{T,F,V,M}\n\n\n\n\n\n","category":"type"},{"location":"others/#HNSW.LayeredGraph-Union{Tuple{T}, Tuple{Int64, Any, Any, Any}} where T","page":"All functions","title":"HNSW.LayeredGraph","text":"LayeredGraph{T}(num_elements, M, M0, m_L)\n\nA multi-layer directed graph with num_elements nodes and edges of type T. The bottom layer contains all points and each upper layer contains a subset of nodes of the one below. M0 is the maximum number of edges in the bottom layer. M is the maximum number of edges in all other layers.\n\nm_L is used for random level generation. ( See 'getrandomlevel' )\n\n\n\n\n\n","category":"method"},{"location":"others/#HNSW.Neighbor","page":"All functions","title":"HNSW.Neighbor","text":"Neighbor{T, F}(idx::T, dist::F)\n\nSimple struct for storing a neighbor index along with its distance to some query element.\n\n\n\n\n\n","category":"type"},{"location":"others/#HNSW.NeighborSet","page":"All functions","title":"HNSW.NeighborSet","text":"NeighborSet(n::Neighbor)\n\nAn ordered List of 'Neighbor', sorted by the dist field. Elements can be added by calling\n\ninsert!(ns::NeighborsSet, n::Neighbor)\n\nand retrieved with\n\nnearest(ns::NeighborSet) → Neighbor\nnearest(ns::NeighborSet, k) → k nearest Neighbors\nfurthest(ns::NeighborSet) → Neighbor\npop_nearest!(ns::NeighborSet) → Neighbor\npop_furthest!(ns::NeighborSet) → Neighbor\n\n\n\n\n\n","category":"type"},{"location":"others/#HNSW.VisitedList-Tuple{Any}","page":"All functions","title":"HNSW.VisitedList","text":"VisitedList(num_elements)\n\nList with num_elements entries to keep track of wether they have been visited or not. Check status with     isvisited(vl::VisitedList, idx) → Bool\n\nand visit with     visit!(vl::VisitedList, idx)\n\nTo reset the list, call 'reset!(vl)'.\n\n\n\n\n\n","category":"method"},{"location":"others/#HNSW.VisitedListPool-Tuple{Real, Real}","page":"All functions","title":"HNSW.VisitedListPool","text":"VisitedListPool(num_lists, num_elements)\n\nA thread-stable container for multiple VisitedLists initialized with num_lists lists with each num_elements entries.\n\nTo retrieve a list, call get_list(vlp::VisitedListPool), and to release ist, call release_list(vlp, vl::VisitedList).\n\n\n\n\n\n","category":"method"},{"location":"others/#HNSW.add!-Union{Tuple{D}, Tuple{HierarchicalNSW, Vector{D}}} where D","page":"All functions","title":"HNSW.add!","text":"add!(hnsw, newdata)\n\nAdd new data to the graph.\n\n\n\n\n\n","category":"method"},{"location":"others/#HNSW.add_to_graph!-Union{Tuple{T}, Tuple{Function, HierarchicalNSW{T}, Any}} where T","page":"All functions","title":"HNSW.add_to_graph!","text":"add_to_graph!(notify_func, hnsw, indices, multithreading=false)\n\nAdd i ∈ indices referring to data[i] into the graph.\n\nnotify_func(i) provides an interface for a progress notification by current index.\n\nIndices already added previously will be ignored.\n\n\n\n\n\n","category":"method"},{"location":"others/#HNSW.add_to_graph!-Union{Tuple{T}, Tuple{HierarchicalNSW{T}, Any}} where T","page":"All functions","title":"HNSW.add_to_graph!","text":"add_to_graph!(hnsw, indices)\n\nshort form of add_to_graph!(notify_func, hnsw, indices)\n\n\n\n\n\n","category":"method"},{"location":"others/#HNSW.insert_point!","page":"All functions","title":"HNSW.insert_point!","text":"insert_point!(hnsw, q, l = get_random_level(hnsw.lgraph))\n\nInsert index query referring to data point data[q] into the graph.\n\n\n\n\n\n","category":"function"},{"location":"others/#HNSW.neighbors-Tuple{Any, Any, Integer}","page":"All functions","title":"HNSW.neighbors","text":"neighbors(lg::LayeredGraph, level, q::Integer)\n\nReturn an Iterator over all links currently assigned.\n\n\n\n\n\n","category":"method"},{"location":"#HNSW.jl","page":"Home","title":"HNSW.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Approximate Nearest Neighbor Searches using the \"Hierarchical Navigable Small World\" (HNSW) algorithm as described in https://arxiv.org/abs/1603.09320 .","category":"page"},{"location":"#Highlights","page":"Home","title":"Highlights","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Written in Julia - no non-julian dependencies\nSupports incremental index creation\nWorks with arbitrary distance functions\nIs data-agnostic - can work with data of arbitrary types given a corresponding","category":"page"},{"location":"","page":"Home","title":"Home","text":"distance function","category":"page"},{"location":"#Creating-an-Index","page":"Home","title":"Creating an Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An Index in this library is a struct of type HierarchicalNSW which can be constructed using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"hnsw = HierarchicalNSW(data; metric, M, efConstruction)","category":"page"},{"location":"","page":"Home","title":"Home","text":"data: This is an AbstractVector of the data points to be used.\nmetric = Euclidean(): The metric to use for distance calculation. Any metric defined in Distances.jl should work as well as any type for which evaluate(::CustomMetric, x,y) is implemented.\nM = 10: The maximum number of links per node on a level >1. Note that value highly influences recall depending on data.\nM0 = 2M: The maximum number of links on the bottom layer (=1). Defaults to M0 = 2M.\nefConstruction = 100: Maximum length of dynamic link lists during index creation. Low values may reduce recall but large values increase runtime of index creation.\nef = 10: Maximum length of dynamic link lists during search. May be changed afterwards using set_ef!(hnsw, value)\nm_L = 1/log(M): Prefactor for random level generation.\nmax_elements = length(data): May be set to a larger value in case one wants to add elements to the structure after initial creation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once the HierarchicalNSW struct is initialized the search graph can be built by calling","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_to_graph!(hnsw [, indices])","category":"page"},{"location":"","page":"Home","title":"Home","text":"which iteratively inserts all points from data into the graph. Optionally one may provide indices a subset of all the indices in data to partially to construct the graph.","category":"page"},{"location":"#Searching","page":"Home","title":"Searching","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Given an initialized HierarchicalNSW one can search for approximate nearest neighbors using","category":"page"},{"location":"","page":"Home","title":"Home","text":"idxs, dists = knn_search(hnsw, query, k)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where query may either be a single point of type eltype(data) or a vector of such points.","category":"page"},{"location":"#A-simple-example:","page":"Home","title":"A simple example:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using HNSW\n\ndim = 10\nnum_elements = 1000\ndata = [rand(dim) for i=1:num_elements]\n\n#Intialize HNSW struct\nhnsw = HierarchicalNSW(data; efConstruction=100, M=16, ef=50)\n\n#Add all data points into the graph\n#Optionally pass a subset of the indices in data to partially construct the graph\nadd_to_graph!(hnsw)\n\n# optionally with a progress notification:\n# step = (num_elements) ÷ 100\n# add_to_graph!(hnsw) do i\n#   if iszero(i % step)\n#     @info \"Processed: $(i ÷ step)%\"\n#   end\n# end\n\nqueries = [rand(dim) for i=1:100]\n\nk = 10\n# Find k (approximate) nearest neighbors for each of the queries\nidxs, dists = knn_search(hnsw, queries, k)","category":"page"}]
}
